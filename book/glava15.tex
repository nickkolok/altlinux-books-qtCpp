\chapter[Разработка приложений с графическим интерфейсом]{Разработка приложений с графическим интерфейсом}
\section[Окна. Класс QMainWindow]{Окна. Класс QMainWindow}
Как уже отмечалось ранее, виджеты, родительский виджет для которых не задан, становятся окнами. Обычно для окон
приложения используют следующие классы:

\begin{itemize}
\item \index{Класс!QMainWindow}\Sys{QMainWindow} --- окно приложения, которое может содержать меню, панели,
строку статуса;
\item \index{Класс!QDialog}\Sys{QDialog} --- диалоговое окно;
\item \index{Класс!QWidget}\Sys{QWidget} --- простое, обычно немодальное окно;
\end{itemize}
Окно обычно имеет обрамление и заголовок. Текст для заголовка окна устанавливают с помощью метода
\Sys{QWidget::setWindowTitle()}. Конструктор класса \Sys{QWidget}
 принимает дополнительный параметр, для типа окна ---
\index{Флаги!Qt::WindowFlags}\Sys{Qt::WindowFlags}. С помощью этого параметра можно
управлять типом обрамления, типом окна (для оконной системы). Например, можно создать окно без обрамления (это полезно
в некоторых случаях для оформления, например, для окна загрузки программы) или деактивировать кнопки для минимизации и
максимизации окна.

\emph{Окно диалога} --- это особый вид окна, который может использоваться для различных
целей, но всегда предоставляет пользователю возможность взаимодействия с программой. Диалоги, как правило, не имеют
кнопок для минимизации и максимизации окна. Окна диалога также часто бывают
\emph{модальными}.
\index{Модальность}\emph{Модальность} окна определяется его поведением.
Модальные окна блокируют доступ к другим окнам, пока пользователь не завершит работу с окном (не закроет его). Задать
модальность окна можно с помощью метода \Sys{QWidget::setWindowModality()}, если
передать ему логическое значение true.

\Sys{QMainWindow} --- класс, реализующий функциональность главного окна приложения. Для этого он дополнительно
имеет специальные средства работы:

\begin{itemize}
\item Главное меню (\EN{Main menu});
\item Панели инструментов (\EN{Toolbars});
\item Панель статуса (\EN{Status bar});
\item Присоединяемые панели (\EN{Docks});
\end{itemize}
Несколько элементов пользовательского интерфейса могут выполнять одно и то же \emph{действие} (например: меню,
кнопка на панели инструментов и т.д.). Класс \index{Класс!QAction}\Sys{QAction} используют для того, чтобы
привязать заданное действие к нескольким элементам управления. Благодаря группировке действия и связанных с ней данных
(названия, подсказки, пиктограммы и т.д.), а также ее многократного использования (в главном меню, на панели
инструментов и т.д.), можно избежать дублирования кода.

\index{Панель!присоединяемая}\emph{Присоединяемые} панели \index{Класс!QDockWidget}\Sys{QDockWidget}
(\EN{dock widgets}), монтируются в крае окна, и могут быть перенесены и перегруппированы
пользователем, или даже разделены и размещены как отдельные окна. Обычно содержат группу элементов пользовательского
интерфейса, объединенных общей целью и назначением или группу инструментов для работы с текущим открытым файлом.

\index{Панель!статуса}\emph{Панель статуса} \index{Класс!QStatusBar}\Sys{QStatusBar}
(\EN{Status bar}) обычно используют для изображения текстовых сообщений о статусе или текущие
действия программы, но она может содержать пиктограммы, а также другие виджеты (например, индикаторы прогресса, метки).

Таким образом, воспользовавшись возможностями главного окна и создав несколько диалогов, можно получить программу,
которая будет соответствовать стандартам современных пользовательских интерфейсов. До сих пор для создания интерфейса
программы нам приходилось самостоятельно создавать и компоновать виджеты. В следующем параграфе мы используем для этой
цели программу \Sys{Qt Designer}, которая позволяет создать интерфейс средствами визуального проектирования.

\section[Быстрая разработка с помощью Qt Designer]{Быстрая разработка с помощью Qt Designer}
Как мы отмечали ранее, есть два подхода, которые можно использовать при построении графического пользовательского
интерфейса, используя виджеты \Sys{Qt}:

\begin{itemize}
\item создать, настроить виджеты и разместить их на форме в соответствующих компоновках с помощью программного кода;
\item воспользоваться визуальным редактором форм \Sys{Qt Designer}, который создаст файл формы (он будет описывать ее внешний
вид, размещение, размеры, настройки, компонование и т.д.). В дальнейшем из файла формы на этапе компиляции будет создан
файл с кодом программы, будет программно создавать этот интерфейс и предоставлять программисту доступ к элементам на
форме.
\end{itemize}
\emph{Файлы }\index{Файл!формы}\emph{формы} имеют расширение \Sys{.ui}. \Sys{Qt Designer} позволяет
редактировать файлы форм, содержащих настройки вида виджетов. \Sys{Qt Designer} можно использовать как отдельную программу
или воспользоваться интеграцией с оболочкой \Sys{Qt Creator} --- редактором форм.

Визуальный \index{Редактор форм}редактор форм позволяет воспользоваться фактически всеми стандартными элементами
управления имеющимися в \Sys{Qt}, настроить значение для их свойств, стилизовать их внешний вид и скомпоновать их на форме.
Также он содержит большое количество инструментов: поле для редактирования формы, редактор сигнально-слотовых
соединений, редактор свойств объектов, средства для работы с компоновками, стилями и~т.~п.

Для того, чтобы продемонстрировать работу редактора форм, создадим новый пример --- простой редактор текста:

\begin{enumerate}
\item Для того, чтобы создать форму главного окна, мы воспользуемся настройками мастера новых проектов. Вызовите мастер
создания файлов и проектов, и выберите тип проекта \Sys{Qt Widgets Application}(Приложение \Sys{Qt Widgets}). 
В окне мастера
введите имя для нового проекта (например: <<\Sys{SimpleTextEditor}>>), выберите также
инструментарий для проекта. В окне \Sys{Class Information} (Информация о классе) выберите
\Sys{QMainWindow} в качестве базового класса главного окна. Также установите флажок \Sys{Generate Form}
(Создать форму) --- это укажет мастеру на необходимость
создания \Sys{.ui}-файла для главного окна (см. рис.~\ref{ch15:refDrawing0}).

\begin{figure}[htb]
\begin{center}
\includegraphics[width=0.7\textwidth]{img/ris_15_1}
\caption[Окно мастера проектов: создание класса главного окна и формы.]{Окно мастера проектов: создание класса
главного окна и формы.}
\label{ch15:refDrawing0}
\end{center}
\end{figure}

\item После создания проекта откройте дерево проекта, и в разделе \Sys{Forms}(Формы) выберите файл формы для главного окна
(\Sys{mainwindow.ui}). \Sys{Qt Creator} сразу перейдет в режим редактирования пользовательского интерфейса
\Sys{Design }(Дизайн). Интерфейс редактора форм состоит из нескольких панелей (см. рис.~\ref{ch15:refDrawing1}).
\item Выберите на панели виджетов <<\Sys{Plain Text Edit}>> и перетащите его мышкой на
форму. Для удобного поиска виджетов вы можете воспользоваться фильтром в верхней части панели. Для поиска виджета
введите его название.
\begin{figure}[htb]
\begin{center}
\includegraphics[width=0.8\textwidth]{img/ris_15_2}
\caption[Интерфейс редактора форм.]{Интерфейс редактора форм: 
1. Панель виждетов (\Sys{Widget box}) 
2. Окно дерева объектов (\Sys{Object inspector})
3. Редактор свойств (\Sys{Property editor}) 
4. Панель переключения режимов работы редактора форм 
5. Редактор действий (\Sys{Action editor}) 
6. Редактор сигнально-слотовых соединений (\Sys{Signals \& Slots editor}) 
7. Центральная часть окна, в которой размещена форма.}
\label{ch15:refDrawing1}
\end{center}
\end{figure}

\item Для того чтобы разместить \Sys{Plain Text Edit} в компоновке внутри главного окна, нажмите правой
кнопкой мыши на свободной от виджетов части формы и выберите в контекстном меню тип компоновки (подменю
\Sys{Lay out}). Для примера мы используем вертикальную компоновку. После выбора компоновки текстовое
поле займет все свободное пространство формы.
\item Добавим главное меню программы. Поскольку для главного окна был избран класс \Sys{QMainWindow}, то панель главного меню
(\Sys{QMenuBar}) , панель статуса (\Sys{QStatusBar}) и панель инструментов (\Sys{QToolBar}) автоматически добавлены к проекту (убедитесь в этом просмотрев дерево объектов). Главное меню расположено в верхней части формы, и пока не содержит ни одного
элемента. Нажмите два раза мышкой на надписи <<Type here>> (Пишите здесь) в главном меню, и введите <<\&File>>. По окончании
ввода нажмите \Sys{Enter} --- на форме появится меню <<File>>. Откройте меню <<File>> и введите так же
еще пункты: <<\&New>>, <<\&Open...>> и <<\&Save...>>. Добавьте разделитель в меню
нажав <<Add separator>> (Добавить разделитель). После этого добавьте еще один пункт --- \Sys{\&Exit.} 
\item Так же добавьте меню <<Edit>> и <<About, добавьте подпункты для этих меню (смотрите на
рисунке ниже). Для того, чтобы к пунктам главного меню можно получить доступ с помощью комбинации клавиш
(Alt+<подчеркнутая буква в названии пункта>), используют символ <<\&>>. Например,
для того чтобы открыть меню File с помощью комбинации Alt+F, название пункта меню задают как <<\&File
(см. рис. \ref{ch15:refDrawing3}--\ref{ch15:refDrawing4}). Все пункты меню и разделители можно упорядочить перетащив
мышкой. Дополнительные подменю можно создать для каждого из пунктов меню, которые уже существуют, нажав на значок
справа от названия пункта. 

{\footnotesize
   \floatsetup[widefloat]{margins=hangleft,font=footnotesize}
   %\captionsetup[figure*]{font=footnotesize}
   \begin{figure}%
   \begin{floatrow}[3]
   \ffigbox[\FBwidth]
   {\caption{Меню <<File>> после редактирования.}%
   \label{ch15:refDrawing3}}
   {\includegraphics[width=0.25\textwidth,keepaspectratio]{img/ris_15_4}}\hspace*{0.03\textwidth}

   %\ffigbox[\Xhsize/2]
   \ffigbox[\FBwidth]%[\FBheight][t]
   {\caption{Меню  <<Edit>>  после редактирования.}%
   \label{ch15:refDrawing2}}
   %{{\setlength\unitlength{\hsize/58}%^^A
   {\includegraphics[width=0.25\textwidth,keepaspectratio]{img/ris_15_3}}\hspace*{0.03\textwidth}
   %}}}
   %\ffigbox[\Xhsize]
   \ffigbox[\FBwidth]%[\FBheight][t]
   {\caption{Меню  <<About>> после редактирования.}%
   \label{ch15:refDrawing4}}
   {\includegraphics[width=0.25\textwidth,keepaspectratio]{img/ris_15_5}}%}
   \end{floatrow}
   \end{figure}%
}

\item Для каждого из пунктов автоматически было создано соответствующее действие (\index{Класс!QAction}\Sys{QAction}). Список
действий можно просмотреть в редакторе действий (Action editor) на одной из страниц нижней панели редактора форм.
Нажмите два раза мышкой на действие --- появится диалоговое окно, в котором можно отредактировать свойства для действия:
текст (Text), имя объекта \Sys{QAction} (Object name), подсказку (ToolTip) --- для панели инструментов, куда будет добавлен
действие, значок (Icon) и комбинацию клавиш для вызова действия (Shortcut). Например, для того, чтобы ввести комбинацию
клавиш, просто нажмите на поле Shortcut и нажмите выбранную комбинацию. Пока мы не будем добавлять горячие комбинации
клавиш. Окончательный вид списка действий после редактирования меню смотрите на рис.~\ref{ch15:refDrawing5} ниже. 

\begin{figure}[htb]
\begin{center}
\includegraphics[width=0.7\textwidth]{img/ris_15_6}
\caption[Вид списка действий в редакторе действий (Action Editor) после редактирования меню]{Вид списка
действий в редакторе действий (Action Editor) после редактирования меню.}
\label{ch15:refDrawing5}
\end{center}
\end{figure}

\item Уже на этапе конструирования пользовательского интерфейса в редакторе форм мы можем создать сигнально-слотовые
соединения между объектами на форме. Для этого перейдите на вкладку Signals \& Slots Editor на нижней панели. Для того,
чтобы добавить новое соединение нажмите на значок с символом <<+>>. Появится новая строка, в которой
двойным щелчком мыши в каждом из столбцов можно вызвать меню со списком доступных вариантов. Выберите в качестве
объекта (Sender) actionExit, который будет посылать сигнал (Signal) triggered(), а в качестве адресата (Receiver)
выберите MainWindow и слот (Slot) close(). Также добавьте остальные сигнально-слотовые соединения для действий, как на
рис. \ref{ch15:refDrawing6}.

\begin{figure}[htb]
\begin{center}
\includegraphics[width=0.7\textwidth]{img/ris_15_7}
\caption[Вид редактора сигналов и слотов (Signals \& Slots Editor) после редактирования]{Вид
редактора сигналов и слотов (Signals \& Slots Editor) после редактирования}
\label{ch15:refDrawing6}
\end{center}
\end{figure}

\item Такие действия как \Sys{Undo} (Отменить), \Sys{Redo} (Повторить), \Sys{Cut} (Вырезать), 
\Sys{Copy} (Копировать), теперь присоединены к соответствующим сигналам \Sys{Plain Text Edit}, 
которые будут сигнализировать о возможности их выполнение действий
пользователя в редакторе. Запустим созданную форму в режиме просмотра --- для этого выберите \Sys{Tools->Form
Editor->Preview...} (Инструменты->Редактор форм->Предпросмотр) или нажмите комбинацию клавиш (Alt+Shift+R). 
Редактор форм загрузит и покажет на экране
форму без предварительной компиляции всей программы. Если мы сразу же откроем меню, 
то увидим что пункты Undo, Redo, Cut, Copy уже активны, хотя изменения, отмены и выделение текста еще не происходило. 
Это связано с тем, что по умолчанию, созданные действия являются активными. Для того чтобы это исправить, откройте дерево объектов (Object Tree), выберите любую из действий для пунктов Undo, Redo, Cut, Copy и 
снимите флажок enabled для них в редакторе свойств (Property Editor). Редактор свойств позволяет настроить каждый из виджетов на форме, изменив значение для их свойств. 
\item Скомпилируйте программу и запустите. Главное окно будет иметь вид, который мы задали на этапе проектирования
формы. Некоторые пункты меню уже работают благодаря сигнально-слотовым соединениям, которые мы сделали.
\end{enumerate}

В следующем параграфе мы продолжим работу над примером и продемонстрируем, как получить доступ к элементам формы из кода
программы.

\section[Программирование формы созданной в Qt Designer]{Программирование формы созданной в Qt Designer}
Рассмотрим, как файлы \index{Файл!формы}форм интегрируются в проект. Как мы уже отмечали ранее, для того чтобы добавить
файл формы в проект существует специальная переменная FORMS. Если мы откроем \Sys{.рro}-файл, то увидим: 

\lstinline!FORMS  += mainwindow.ui!

Файлы форм, добавленные в проект, считываются и превращаются в эквивалентный \Sys{С++} код с помощью 
специальной программы \Sys{uic}
(это происходит во время предварительной обработки проекта с помощью \Sys{qmake}). 
Код, сгенерированный \Sys{uic}, создает виджеты и
компоновки, содержит настройки свойств, сигнально-слотовые соединения и стили, необходимые для получения визуального
отображения содержимого \index{Файл!.ui}\Sys{.ui}-файла. Если мы откроем папку с проектом (или папку для shadow build), то увидим среди исходных текстов и сгенерированных файлов файл \Sys{ui\_mainwindow.h}, содержащий сгенерированный для формы код.
Конечно, этот файл должен быть добавлен где-то в коде программы с помощью директивы \Sys{\#include} для того, чтобы можно
было воспользоваться сгенерированным кодом. Но нет необходимости делать это самостоятельно --- гораздо легче
воспользоваться мастером создания файлов и проектов. 

При создании проекта для нашего примера мы установили флажок <<Generate form>> для того, чтобы автоматически сгенерировать
форму для главного окна и добавить необходимый код для доступа к элементам на форме в программе. Среди кода, мастер
автоматически добавил к объявлению и реализации класса \Sys{MainWindow}: 

\begin{itemize}
\item предварительное объявление класса формы: 
\begin{lstlisting}
//`Предварительное объявление класса формы созданной из \Sys{.ui}-файла`
namespace Ui {
    class MainWindow;
}
\end{lstlisting}

\item указатель на объект формы, позволяющий получить доступ к элементам на форме: 
\begin{lstlisting}
class MainWindow : public QMainWindow
{
.....
private:
    //`Указатель на объект формы созданной из \Sys{.ui}-файла` 
    Ui::MainWindow *ui;    
};
\end{lstlisting}

\item Конструктор главного окна создает объект класса формы и инициализирует переменную \Sys{ui}, 
а также вызывает метод \Sys{ui->setupUi(this)}, который создает все элементы которые есть на форме и 
устанавливает текущий виджет как родительский для них; 
\begin{lstlisting}
//`Файл сгенерированный uic при обработке файла формы`
#include "ui_mainwindow.h"
MainWindow::MainWindow(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::MainWindow) //`Создаем объект формы, созданной в QtDesigner` 
{    
ui->setupUi(this); //`Применяем дизайн, который мы создали в QtDesigner к текущему окну` 
.....
\end{lstlisting}

\item Деструктор: удаляет объект на который ссылается указатель ui 
\begin{lstlisting}
MainWindow::~MainWindow()
{
  //`Удалить форму из памяти`
  delete ui;
}
\end{lstlisting}
\end{itemize}

Таким образом, через указатель \Sys{ui} мы можем получить доступ к созданной форме и элементам на ней. 
Например, мы можем
получить доступ к действиям добавленным к главному меню нашего редактора и задать 
горячие клавиши для них:
\begin{lstlisting} 
//`Задаём комбинации клавиш для действий`
  ui->actionUndo->setShortcut(QKeySequence::Undo);
  ui->actionRedo->setShortcut(QKeySequence::Redo);
  ui->actionCut->setShortcut(QKeySequence::Cut);
  ui->actionC_opy->setShortcut(QKeySequence::Copy);
  ui->action_Paste->setShortcut(QKeySequence::Paste);
  ui->actionSelect_all->setShortcut(QKeySequence::SelectAll);
  ui->action_New->setShortcut(QKeySequence::New);
  ui->action_Open->setShortcut(QKeySequence::Open);
  ui->action_Save->setShortcut(QKeySequence::Save);
  ui->action_Exit->setShortcut(QKeySequence::Quit);
\end{lstlisting}

Обратите внимание на то, как мы используем класс \Sys{Qt} \index{Класс!QKeySequence}\Sys{QKeySequence} 
для того, чтобы задать
горячие клавиши для действий. Помимо возможности задать комбинацию клавиш текстовой строкой 
(например \Sys{QKeySequence} (Ctrl + X)) или с помощью специально определенных констант для 
клавиш (например \Sys{QKeySequence} (Qt :: CTRL + Qt :: Key\_X)), можно воспользоваться 
набором стандартных клавиатурных сокращений, которые будут соответствовать стандартам системы. 
Так для повторения отмененного действия в ОС Linux пользователь сможет воспользоваться комбинацией
клавиш Ctrl+Shift+Z, а в ОС Windows привычной комбинацией Ctrl+Y. 

Нашему текстовому редактору еще не хватает функциональности: нам необходимо запрограммировать создание, открытие и
сохранение текстового файла, а также пункты меню \Sys{Help}.

Для начала добавим объявления слота для создания нового файла и добавим поле для сохранения пути текущего открытого
файла: 
\begin{lstlisting}
private slots:
  void slotNew();

private:
  QString mFileName;
\end{lstlisting}

Мы используем частный метод \Sys{updateTitle()} для того, чтобы обновить заголовок окна и вывести название 
программы и путь к текущему открытому файлу: 
\begin{lstlisting}
private:
  void updateTitle();
\end{lstlisting}

Реализация метода обновления заголовка: 
\begin{lstlisting}
//`Метод обновления заголовка окна`
void MainWindow::updateTitle()
{
//`Подставляем в название заголовке имя поточнго открытого файла. Комбинацией символов` "[*]" 
//`обозначаем место, где будет выводиться знак` "*"` в случае, когда содержимое окна модифицировано.
QString lTitle=QString("TextEditor- %1[*]").arg(mFile.fileName());
// устанавливаем заголовок окна 
setWindowTitle(lTitle);
}
\end{lstlisting}


Метод \Sys{setWindowTitle()} позволяет не только задать текст заголовка для окна, 
но и отметить несохраненные изменения в
текущем открытом документе. Для этого, после заголовка мы добавили шаблон [*]. 
Теперь, если сообщить главному окну о
редактировании содержимого посредством вызова слота \Sys{QWidget::setWindowModified(bool)} 
со значением \Sys{true}, то после текста
заголовка появится символ «*», означающий, что содержание главного окна изменено 
и его следует сохранить. Слот
\Sys{setWindowModified(bool)} мы соединили с сигналом \Sys{modificationChanged(bool)} 
текстового поля \Sys{QPlanTextEdit} с помощью
редактора сигнально-слотовых соединений в редакторе форм (см. предыдущий пункт). 

Добавим реализацию слота  \lstinline!MainWindow::slotNew()!:
\begin{lstlisting}
//`Слот для создания нового документа`
void MainWindow::slotNew()
{
  mFileName = "UntitledFile";//`Задать имя для нового файла по умолчанию`
  ui->plainTextEdit->clear(); //`Очистить текстовое поле`
  setWindowModified(false);//`Установить --- содержание не модифицировано`
  updateTitle();//`Обновить заголовок окна`
}
\end{lstlisting}

Теперь присоединим объект \index{Класс!QAction}\Sys{QAction} для создания нового документа к слоту: 

\lstinline!connect(ui->action_New, SIGNAL(triggered()),this, SLOT(slotNew()), Qt::UniqueConnection);!

Сигнал выпускается при выполнении действия (вызова пункта меню, нажатие кнопки на панели инструментов, для которой была
добавлено действие и~т.д.). В конце конструктора вызовем слот \Sys{slotNew()}: 
\begin{lstlisting}
MainWindow::MainWindow(QWidget *parent) :
    QMainWindow(parent),
ui(new Ui::MainWindow) 
//`Создаем объект, который содержит дизайн созданный в редакторе форм`
{
......
//`В конце вызываем слот для нового документа. Таким образом, пользователь сможет сразу же приступить к работе`
  slotNew();
}
\end{lstlisting}

Остальные пункты меню мы запрограммируем в следующем параграфе, в котором мы рассмотрим работу со стандартными
системными диалогами в \Sys{Qt}. 

\section[Стандартные диалоги]{Стандартные диалоги}
Диалог выбора файла для открытия и сохранения, диалог выбора шрифта, окна сообщений об ошибках являются примерами
диалоговых окон, с которыми часто приходится сталкиваться при работе с программами. Такие диалоги обычно имеют
стандартные для всех программ в системе вид и функциональность. \Sys{Qt} позволяет воспользоваться готовыми диалогами для
этих целей, которые легко вызвать в программе. Классы для работы с диалогами, которые часто используют в программе,
приведены в табл.~\ref{ch15:refTable0}.

{\noindent\small
\begin{longtable}{|c|p{0.78\textwidth}|}
\caption{Некоторые классы готовых диалогов \Sys{Qt}} \label{ch15:refTable0}\\
\hline
\Emph{Класс} & \Emph{Описание особенностей}\\
\hline\hline
\endfirsthead
\multicolumn{2}{c}%
{{\tablename\ \thetable{} --- продолжение}} \\
\hline
\Emph{Класс} & \Emph{Описание особенностей}\\
\hline\hline
\endhead
\index{Класс!QInputDialog}\Sys{QInputDialog} &
Используют для удобства в случае когда необходимо ввести числовое значение или строку текста. Имеет несколько сигналов,
которые сигнализируют об изменении значения в поле ввода. Класс имеет статические методы для вызова диалога ввода числа
(\Sys{getDouble(), getInt()}), ввода (\Sys{getText()}) выбора элемента из списка
(\Sys{getItem()}). \\\hline
\index{Класс!QColorDialog}\Sys{QColorDialog} &
Стандартный диалог выбoра цвета. Класс имеет статический метод \Sys{getColor()} для удобного вызова диалога.
\\\hline
\index{Класс!QFontDialog}\Sys{QFontDialog} &
Стандартный диалог выбoра шрифта. Класс имеет статический метод \Sys{getFont()} для удобного вызова диалога.
\\\hline
\index{Класс!QFileDialog}\Sys{QFileDialog} &
Стандартный диалог выбора файла. Имеет большое количество настроек, возможность фильтрации файлов по расширению. Класс
имеет статические методы (\Sys{getExistingDirectory(), getOpenFileName(), getOpenFileNames(),
getSaveFileName()}) для вызова диалога. \\\hline
\index{Класс!QMessageBox}\Sys{QMessageBox} &
Диалог сообщение. Используют для вывода информации, сообщений об ошибках и вопросов. Класс имеет статические методы для
удобного вызова в программе информационных окон (\Sys{about(), aboutQt()}), сообщений об ошибках
(\Sys{critical(), warning()}), вопросов (\Sys{question()}) и сообщений
(\Sys{information()}). \\\hline
\end{longtable}
}

В нашем примере мы будем использовать класс \Sys{QFileDialog} для выбора файла при открытии и сохранении, а
также класс \index{Класс!QMessageBox}\Sys{QMessageBox}. Добавим описание слотов для открытия и сохранения
файла: 
\begin{lstlisting}
private slots:
void slotOpen();
void slotSave();
\end{lstlisting}

Подключим необходимые заголовочные файлы в \Sys{mainwindow.cpp}: 
\begin{lstlisting}
#include <QFileDialog>
#include <QMessageBox>
#include <QDir>
\end{lstlisting}

Добавим реализацию для слотов \Sys{slotOpen()} и \Sys{slotSave()}: 
\begin{lstlisting}
//`Слот для открытия файла в редакторе` 
void MainWindow::slotOpen()
{
  //`Вызвать системный диалог открытия файла в домашней папке пользователя` 
  QString lFileName=QFileDialog::getOpenFileName(this, "Open file...", QDir::homePath(), "Text files (*.txt);;All files (*.*)"); //`указываем фильтры для просмотра файлов` 
  if (lFileName.isEmpty())//`Если пользователь не выбрал ни одного файла`
  {
    return; //`выйти из метода`
  }
  //`Спросить пользователя о сохранении документа`
  if (!askForFileSaveAndClose())
  {
  //`Если пользователь нажал <<Отмена>> игнорировать вызов --- продолжать работу`
    return;
  }
  QFile lFile(lFileName);//`Устанавливаем имя открытого файла`
  //`Если текстовый файл открыт только для чтения...` 
  if (lFile.open(QIODevice::ReadOnly | QIODevice::Text))
  {
    mFileName = lFileName;//`задать имя файла`
    //`читаем все содержимое и устанавливаем текст для редактора`
    ui->plainTextEdit->setPlainText(lFile.readAll());
    lFile.close(); //`закрываем открытый файл`
    //`устанавливаем состояние окна --- содержимое не модифицировано`
    setWindowModified(false);
    //`и обновляем заголовок окна для демонстрации названия текущего открытого файла` 
    updateTitle();
  }
  else
  {
    //`Если при открытии файла возникла ошибка выводим диалоговое окно с сообщением,` 
    //`содержащим имя файла, одну кнопку <<Ок>> и заголовок <<Error>>` 
    QMessageBox::warning(this, "Error", QString("Could not open file %1 for reading").arg(lFile.fileName()), QMessageBox::Ok);
  }
}
//`Слот для сохранения изменений в текущем файле` 
void MainWindow::slotSave()
{
  //`Если содержимое не модифицировано...`
  if (!isWindowModified()) //`Если содержимое не модифицировано`
  {
    return; //`Выйти из метода --- продолжить работу`
  }
  //`Вызвать системный диалог сохранения файла в домашней папке пользователя`
  QString lFileName=QFileDialog::getSaveFileName(this, tr("Save file..."), QDir::homePath(), tr("Text files (*.txt);;All files (*.*)"));
  //`Если пользователь не выбрал имя файла для сохранения...`
  if (lFileName.isEmpty())
  {
    return;//` ... выйти из метода`
  }
  QFile lFile(lFileName); //`Устанавливаем имя открытого файла` 
  //`Если текстовый файл открыт для записи`
  if (lFile.open(QIODevice::WriteOnly | QIODevice::Text))
  { 
     mFileName = lFileName; //`Задать имя файла`
    //`Создаем временный QByteArray для записи данных`
    QByteArray lData; 
    //`Читаем текст из редактора и добавляем QByteArray, записываем в файл и закрываем файл после записи` 
    lData.append(ui->plainTextEdit->toPlainText());
    lFile.write(lData);
    lFile.close();
    //`Устанавливаем состояние окна --- содержимое не модифицировано`
    setWindowModified(false);
  }
  else
  {
    //`Если при открытии файла возникла ошибка выводим диалоговое окно с сообщением,`
    //`содержащим имя файла, одну кнопку <<Ок>> и заголовок <<Error>>` 
    QMessageBox::warning(this, "Error", QString("Could not open file %1 for writing").arg(lFile.fileName()), QMessageBox::Ok);
  }
}
\end{lstlisting}

Здесь в начале каждого из слотов мы вызываем диалог для выбора файла с помощью статических методов класса \Sys{QFileDialog}.
Диалог для открытия файла мы вызываем с помощью метода \lstinline!QFileDialog::getOpenFileName()!, а для сохранения --- с помощью
\lstinline!QFileDialog ::getSaveFileName()!. Для каждого из случаев диалог будет иметь соответствующий вид. Для того, чтобы
добавить фильтр для текстовых файлов мы передаем строку с описанием фильтра --- <<Text files (*.txt );;All files
(*.*)>>. В описании --- названия для фильтров и шаблоны для фильтрации (в скобках). Можно задавать несколько
шаблонов через пробел при необходимости. Фильтры в списке разделяем с помощью двойной точки с запятой. 

После выбора пользователем файла, статический метод вернет полный путь к нему. В случае, когда пользователь закрыл
диалог или нажал <<Отмена>>, метод вернет пустую строку. Для выбранного файла мы выполняем чтение
содержимого и сохранения. Если при открытии возникла ошибка, мы выводим ее с помощью статического метода
\lstinline!QMessageBox::warning()!. 

При открытии файла мы использовали собственный метод \lstinline!askForFileSaveAndClose()!, который должен проверить текущий открытый
файл на изменения и предложить пользователю сохранить их перед открытием другого файла. Добавим описание этого метода к
описанию класса \Sys{MainWindow}: 
\begin{lstlisting}
private:
  bool askForFileSaveAndClose();
\end{lstlisting}

и его реализацию в файл  \Sys{mainwindow.cpp}:
\begin{lstlisting}
//`Метод для проверки текущего файла на изменения и вывода диалога для пользователя, с предложением` 
//`сохранить изменения. Метод возвращает логическое значение, содержащее \Sys{false} в случае,` 
//`когда пользователь нажал в диалоге кнопку <<Cancel>>` 
bool MainWindow::askForFileSaveAndClose()
{
  if (isWindowModified()) //`Если содержимое окна модифицировано`
  {
  //`вызываем диалог с вопросом, нужно ли сохранять изменения: подставляем в текст диалога название`
  //`текущего открытого файла, задаем кнопки: <<Да>>, <<Нет>> и <<Отмена>>.`
  //`Результат работы диалога (нажатой кнопки) записываем в переменную`
    int lResult = QMessageBox::question(this, tr("Save changes"),
    QString(tr("File %1 is modified. Do you want to save your changes?")).arg(mFile.fileName()), QMessageBox::Yes, QMessageBox::No, QMessageBox::Cancel);
    if (QMessageBox::Yes == lResult)//`Если нажали кнопку <<Да>>`
    {
      slotSave(); //`сохранить изменения` 
    }
    else
    {
      if (QMessageBox::Cancel == lResult) //`Если нажали кнопку <<Отменить>>`
      {
        return false;
      }
    }
  }
  return true;
}
\end{lstlisting}

В этом фрагменте программы мы использовали статический 
метод \index{Класс!QMessageBox}\Sys{QMessageBox :: question}, и задали
заголовок, текст и кнопки на диалоге с помощью специальных констант (\Sys{QMessageBox::Yes},
 \Sys{QMessageBox::No}, \Sys{QMessageBox::Cancel}). Он, как и почти все статические 
методы \Sys{QMessageBox}, возвращает значение нажатой кнопки. Это
значение мы сравниваем со значениями констант для кнопок, чтобы определить, 
какие дальнейшие действия выбрал
пользователь. Используем метод \lstinline!askForFileSaveAndClose()! 
также и в слоте для нового текстового файла: 
\begin{lstlisting}
//`Спросить пользователя о сохранении документа`
if (!askForFileSaveAndClose())
{
  //`Если пользоватеель нажал <<Отменить>> игнорировать вызов --- продолжать работу` 
  return;
}
\end{lstlisting}

Осталось реализовать вывод информации о программе. Для этого сначала добавим к
\Sys{.pro}-файлу информацию о версии. Например, добавим переменные с большим и меньшим
номерами версии, а потом передадим их в переменную \index{Переменные qmake!DEFINES}\Sys{DEFINES} 
таким образом, чтобы они
были объявлены в программе. Это может быть удобно для дальнейшего изменения версии 
при разработке программы: 

\begin{lstlisting}
MAJOR_VERSION = 1
MINOR_VERSION = 0
DEFINES += \
    MAJOR_VERSION=$$MAJOR_VERSION \
    MINOR_VERSION=$$MINOR_VERSION
\end{lstlisting}

После изменений в файле проекта не забудьте вызвать \Sys{qmake} еще раз, чтобы программа 
обработала все изменения в файле
проекта (выберите в главном меню \Sys{Build->Run qmake}) Теперь в файле \Sys{main.cpp} зададим версию, а также
название для \index{Класс!QApplication}\Sys{QApplication}: 
\begin{lstlisting}
int main(int argc, char *argv[])
{
  QApplication a(argc, argv);
  a.setApplicationName("TextEditor");
  a.setApplicationVersion(QString("%1.%2")
    .arg(MAJOR_VERSION)
    .arg(MINOR_VERSION));
  MainWindow w;
  w.show();
  return a.exec();
}
\end{lstlisting}

Теперь используем объект \Sys{QApplication} для получения версии и названия программы в слоте отображения информации. Добавим
объявления слота, а также следующую его реализацию: 
\begin{lstlisting}
//`Слот для отображения информации о программе`
void MainWindow::slotAboutProgram()
{
  //`Выводим диалоговое информационное окно с сообщением, куда подставляем версию и название`
  //`программы возвращаемых QApplication. Указываем --- окно содержит заголовок <<About>>.`
  QMessageBox::about(this, tr("About"), 
  QString("%1 v. %2").arg(qApp->
  applicationName()).arg(qApp->applicationVersion()));
}
\end{lstlisting}

В конце подсоединяем сигналы от пунктов главного меню к созданным слотам: 
\begin{lstlisting}
//`Присоединяем действия к созданным слотам`
connect(ui->action_New, SIGNAL(triggered()), this, SLOT(slotNew()), Qt::UniqueConnection);
connect(ui->action_Open, SIGNAL(triggered()), this, SLOT(slotOpen()), Qt::UniqueConnection);
connect(ui->action_Save, SIGNAL(triggered()), this, SLOT(slotSave()), Qt::UniqueConnection);
connect(ui->actionAbout_Qt, SIGNAL(triggered()), qApp, SLOT(aboutQt()), Qt::UniqueConnection);
connect(ui->actionAbout_program, SIGNAL(triggered()), this, SLOT(slotAboutProgram()), Qt::UniqueConnection);
\end{lstlisting}

\section[Ресурсы программы]{Ресурсы программы}
Часто бывает необходимо добавить в программу дополнительные файлы такие как изображения и значки, используемые при
оформления интерфейса, звуковые файлы для уведомлений пользователя, сценарии, выполняемые программой и т.д. В таких
случаях можно воспользоваться преимуществами, которые предоставляет ресурсная система \Sys{Qt}. 

\index{Ресурсы}Добавляя файл как ресурс в программу, мы указываем, что хотим включить данные, содержащиеся в этом файле
в исполняемый файл. Таким образом скомпилированная программа будет содержать все ресурсные файлы внутри. Средства \Sys{Qt}
позволяют обращаться к этим данным, и считывать файлы в ресурсах так же, как и обычные файлы в файловой системе. 

Для демонстрации работы с ресурсами в \Sys{Qt} добавим изображения для пунктов меню и кнопки на панель инструментов текстового
редактора. 

\begin{enumerate}
\item В папке проекта создадим подкаталог \Sys{resources}. Внутри добавим еще одну вложенную папку с названием
\Sys{images} и добавим туда значки для меню. 
\item Вызовем мастер создания новых файлов и проектов. Выберем раздел \Sys{Qt} и создадим
\Sys{Qt Resource File} (Файл\index{Файл!ресурсов}ресурсов \Sys{Qt}). В следующем окне мастера, 
введем для файла имя в поле \Sys{Name} (Имя): \Sys{resources.qrc}. В поле \Sys{Path} (Путь) нажмем на 
кнопку и в диалоге выберем созданную папку \Sys{resources}. Нажмем \Sys{Next} (Далее) и в 
следующем окне \Sys{Finish} (Завершить). 
\item Выберем созданный файл ресурсов в дереве проекта (раздел \Sys{Resources}) и откроем его. В главном
окне \Sys{Qt Creator} появится редактор ресурсов, который состоит из браузера ресурсов (сверху) и панели редактирования
(снизу). На нижней панели выберите \Sys{Add-> Add Prefix} (Добавить->Добавить префикс). Сразу же
в редакторе появится раздел для ресурсов и станет доступным для редактирования его название (поле
\Sys{Prefix}). Установите название для раздела: \Sys{actions}. 
\item Выберите раздел \Sys{actions} в редакторе ресурсов и нажмите внизу на панели \Sys{Add-> Add Files}
 (Добавить->Добавить файлы). В диалоге выбора файлов откройте папку \Sys{resources/images} внутри папки с
проектом, выберите все файлы в папке и нажмите \Sys{Open}. Пиктограммы сразу будут добавлены в раздел и
показаны в редакторе. 
\item Для каждой из пиктограмм можно выбрать псевдоним --- второе имя по которому к пиктограмме 
можно получить доступ. Это
делают для того, чтобы при изменении файла не нужно было менять путь к изображению в коде программы. 
Для этого
достаточно добавить другое изображение и установить такой же псевдоним как для старого, а старому 
изображению, в свою
очередь, удалить псевдоним. Установите псевдоним для каждого из изображений согласно действию для которого они
предназначены (смотрите на рис.~\ref{ch15:refDrawing7}).
\item Изображение для действия можно добавить в коде программы вызвав для действия метод
\Sys{QAction::setIcon()}. Например: \lstinline!ui->action_New->setIcon(QIcon(":/actions/new"));! 

\begin{figure}[htb]
\begin{center}
\includegraphics[width=0.7\textwidth]{img/ris_15_8}
\caption[Редактирование файла ресурсов]{Редактирование файла ресурсов}
\label{ch15:refDrawing7}
\end{center}
\end{figure}

Обратите внимание на то, как мы указываем путь к файлу с изображением в ресурсах программы. Для того чтобы получить
доступ к ресурсам мы начинаем путь с символов $:/$. Далее мы указываем раздел, куда мы добавили
пиктограммы --- \Sys{actions}, и затем указываем псевдоним для самого изображения в ресурсной системе ---
\Sys{new}. Для того, чтобы установить изображение для действия, мы создаем временный объект
\index{Класс!QIcon}\Sys{QIcon}, которому передаем путь к изображению. 

Для того, чтобы добавить изображение для действий, мы воспользуемся другим способом и добавим изображение в редакторе
действий. Для этого перейдите к редактору действий, два раза нажмите на действие и в диалоге редактирования нажмите
на кнопку <<...>> в поле \Sys{Icon} (Значок).
Выберите нужное изображение из ресурсов. Так же измените и другие действия. 

\item Добавим действий теперь также и в панель инструментов. Для этого перетащите действие из редактора действий на
панель инструментов, которая расположена прямо под главным меню на форме. Для того, чтобы добавить разделитель нажмите
правой кнопкой на панели и выберите \Sys{Append Separator}. Выберите в редакторе свойств для панели
инструментов свойство \Sys{toolButtonStyle} и установите его в значение
\Sys{ToolButtonTextUnderIcon}. Запустите просмотр для формы (см. рис.~\ref{ch15:refDrawing8}).
\end{enumerate}

\begin{figure}[htb]
\begin{center}
\includegraphics[width=0.7\textwidth]{img/ris_15_9}
\caption[Редактор с панелью инструментов]{Редактор с панелью инструментов}
\label{ch15:refDrawing8}
\end{center}
\end{figure}


\section[Создание собственных диалогов]{Создание собственных диалогов}
Для нашего примера мы создадим диалог настроек, с помощью которого мы будем изменять вид главного окна. 

\begin{enumerate}
\item Вызовем мастер новых файлов и проектов. Выберем раздел \Sys{Files and Classes->Qt}
(Файлы и классы -> Qt) и \Sys{Qt Designer Form Class} (\index{Создание!Класса формы Qt Designer}
Класс формы Qt Designer) для создания класса окна вместе с файлом формы. Выберем в окне
\Sys{Choose a Form Template} (Выбор шаблона формы) шаблон для нового окна ---
\Sys{Dialog with Buttons Bottom} (Диалог с кнопками внизу) и нажмите
\Sys{Next}. Этим мы укажем мастеру создать окно, унаследовав класс от \Sys{QDialog} и
добавить внизу формы дополнительно две кнопки \Sys{Ok} и \Sys{Cancel} (см. рис.~\ref{ch15:refDrawing9}). 
\item \Sys{QDialog} может возвращать значение после завершения, которое можно получить с помощью метода
\Sys{int result()}. Перед выходом из диалога должен вызываться один из двух методов:
\Sys{QDialog::accept()} или \Sys{QDialog::reject()}. Они изменяют значение
\Sys{QDialog::result()} на \Sys{QDialog::Accepted} и \Sys{QDialog::Rejected}
соответственно и закрывают диалог. Обратите внимание, что после создания формы для диалога, кнопки внутри
\Sys{QDialogButtonBox} были автоматически подключены к слотам диалога \Sys{accept()} и
\Sys{reject()} (убедитесь в этом открыв редактор сигнально-слотовых соединений в редакторе форм для диалога).
Также \index{Класс!QDialog}\Sys{QDialog} можно вызвать с помощью метода \Sys{exec()}, который также
возвращает результат его выполнения. В этом случае диалог вызывается как модальный. 

\item В следующем окне (см. рис. \ref{ch15:refDrawing10}) напишем имя класса для окна: \Sys{SettingsDialog}
(поле \Sys{Class name}). Нажмем кнопку \Sys{Next} и в следующем окне нажмем
\Sys{Finish}. Откроем форму в редакторе. На форме мастер автоматически добавил \Sys{Diаlog Button Box} с
двумя кнопками <<Ok>> и <<Cancel>>.

\begin{figure}[htb]
\begin{center}
\includegraphics[width=0.7\textwidth]{img/ris_15_10}
\caption[Создание диалога настроек (шаг 1).]{Создание диалога настроек (шаг 1).}
\label{ch15:refDrawing9}
\end{center}
\end{figure}

\item Наш диалог будет содержать одну группу настроек. Это будут настройки вида окна, а именно настройки видимости
панели инструментов и строки статуса. Для этого перетащим на форму элемент Group Box. Для того чтобы отредактировать
заголовок два раза нажмите мышкой на тексте надписи или выберите свойство \Sys{title} в редакторе свойств.
Измените заголовок на \Sys{View Settings}.
\item Перетащите два флажка в \Sys{Group Box} и назовите их \Sys{Show Toolbar} и \Sys{Show Status
Bar} (см. рис.~\ref{ch15:refDrawing11}). Выберите свойство \Sys{objectName} для
каждого из них и установите в \Sys{showToolbarCheckBox} и
\Sys{showStatusBarCheckBox} соответственно. Нажмите правой кнопкой мыши внутри элемента 
\Sys{Group Box} и выберите \Sys{Lay out->Lay out Horizontally} (Компоновка->Скомпоновать по
горизонтали). Флажки расположатся в горизонтальной компоновке внутри элемента \Sys{Group Box}.
\begin{figure}[htb]
\begin{center}
\includegraphics[width=0.7\textwidth]{img/ris_15_11}
\caption[Создание диалога настроек (шаг 2).]{Создание диалога настроек (шаг 2).}
\label{ch15:refDrawing10}
\end{center}
\end{figure}

\item Нажмите на свободном от элементов пространстве формы и выберите в контекстном меню 
\Sys{Layout->Lay out Vertically} (Компоновка->Скомпоновать по вертикали). 
Элементы \Sys{Group Box} и \Sys{Button Box} расположатся в вертикальной компоновке на форме. 
\item Измените размер формы. Для этого выберите \Sys{SettingsDialog} в дереве объектов и подведите указатель
мышки к краю формы или выберите свойство \Sys{geometry} и измените. Сделайте размер формы меньше. В редакторе
свойств выберите флажок \Sys{modal} и установите его. Измените свойство \Sys{windowTitle} на
<<Settings>>. 
\end{enumerate}
\begin{figure}[htb]
\begin{center}
\includegraphics[width=0.3\textwidth]{img/ris_15_12}
\caption[Пример: Диалог настроек для проекта SimpleTextEditor.]{Пример: Диалог настроек для проекта
SimpleTextEditor.}
\label{ch15:refDrawing11}
\end{center}
\end{figure}

Объявление класса диалога настроек (\Sys{settingsdialog.h}):
\begin{lstlisting}
class SettingsDialog : public QDialog
{
    Q_OBJECT
public:
    explicit SettingsDialog(QWidget *parent = 0);
    ~SettingsDialog();
    bool isShowToolBar() const;
    void setShowToolBar(bool pShow);
    bool isShowStatusBar() const;
    void setShowStatusBar(bool pShow);
private:
    Ui::SettingsDialog *ui;
};
\end{lstlisting}


Также реализуем методы для установки и получения значения флажков (\Sys{settingsdialog.h}):
\begin{lstlisting}
bool SettingsDialog::isShowToolBar() const
{
  return ui->showToolbarCheckBox->isChecked();
}
void SettingsDialog::setShowToolBar(bool pShow)
{
  ui->showToolbarCheckBox->setChecked(pShow);
}
bool SettingsDialog::isShowStatusBar() const
{
  return ui->showStatusBarCheckBox->isChecked();
}
void SettingsDialog::setShowStatusBar(bool pShow)
{
  ui->showStatusBarCheckBox->setChecked(pShow);
}
\end{lstlisting}


Добавим вызов диалога из программы. Для этого в файле \Sys{mainwindow.h} сделаем предварительное объявление:

\lstinline!class SettingsDialog;!

и добавим объявление слота, который будет показывать диалог и переменную, указывающую на объект диалога настроек: 
\begin{lstlisting}
private slots:
 void showPreferencesDialog();
private:
 SettingsDialog *mSettingsDialog;
\end{lstlisting}

В файле \Sys{mainwindow.cpp} подключите файл описания класса \Sys{SettingsDialog}: 

\lstinline!#include "settingsdialog.h"!

Создаем диалог настроек 
\begin{lstlisting}
MainWindow::MainWindow(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::MainWindow),
mSettingsDialog(new SettingsDialog(this))
//`Создаем диалог настроек`
{
ui->setupUi(this);//`Применяем дизайн, который мы создали в редакторе форм в текущем окне`
\end{lstlisting}

и добавляем реализацию для слота, который вызовет диалог: 

\begin{lstlisting}
void MainWindow::showPreferencesDialog()
{
    //`Показываем диалог настроек`
    mSettingsDialog->show();
}
\end{lstlisting}

В конце добавляем сигнально-слотовое соединение, которое присоединит сигнал от меню к слоту: 

\begin{lstlisting}
connect(ui->actionPr_eferences, SIGNAL(triggered()), mSettingsDialog, SLOT(showPreferencesDialog()),  Qt::UniqueConnection);
\end{lstlisting}

Конечно, мы могли присоединить сигнал к слоту \Sys{show()} диалога напрямую, но в следующем параграфе мы
рассмотрим, как хранить в системе и считывать настройки нашей программы, и перед тем как вызвать диалог мы добавим код,
который будет инициализировать диалог настроек. 

А пока суммируем наши знания о дизайнере форм. Алгоритм работы с дизайнером форм выглядит примерно так:

\begin{enumerate}
\item Примерно разместить виджеты на форме;
\item Применить к виджетам компоновки, начиная с наиболее вложенных виджетов;
\item Добавить меню, панели, настроить действия;
\item Настроить объекты на форме с помощью редактора свойств;
\item Сделать сигнально-слотовые соединения, если необходимо;
\item Реализовать логику работы в исходном коде программы. 
\end{enumerate}

\section[Сохранение настроек]{Сохранение настроек}
Для сохранения настроек в программе мы воспользуемся классом \Sys{QSettings}. Он позволяет сохранять настройки
программы стандартным для программной платформы способом. В ОС Linux и Mac OS X это конфигурационные файлы
(\Sys{.ini} и. \Sys{.plist}), а под
управлением ОС Windows настройки программы можно сохранять в системный реестр. Также класс
\index{Класс!QSettings}\Sys{QSettings} часто используют для редактирования произвольных.
\Sys{.ini} и \Sys{.plist} файлов и ключей системного реестра
Windows.

Чтобы добавить поддержку сохранения настроек в программе объявим несколько дополнительных методов. 
\begin{lstlisting}
private slots:
  void slotPreferencesAccepted();
private:
  void readSettings();
  void writeSettings();
  void applySettings();
\end{lstlisting}

Метод \Sys{readSettings} будет читать настройки программы и инициализировать настройками наш диалог. Метод
\Sys{writeSettings} будет читать настройки, установленные в диалоге, и записывать их. Наконец метод
\Sys{applySettings} будет получать текущие настройки от диалога и настраивать соответствующим образом
программу. 
\begin{lstlisting}
void MainWindow::readSettings()
{
//`Указываем, где хранились настройки. \Sys{QSettings::NativeFormat} --- в формате определенном системой`
//`\Sys{QSettings::UserScope} --- настройки для каждого пользователя отдельно.` 
//`Также устанавливаем имя организации и название программы` 
  QSettings lSettings(QSettings::NativeFormat, QSettings::UserScope,"", qApp->applicationName());
//`Открываем группу настроек` 
  lSettings.beginGroup(SETTINGS_GROUP_VIEW);
//`Читаем настройки` 
  bool lShowToolBar=lSettings.value(SETTING_SHOW_TOOLBAR, true).toBool();
  mSettingsDialog->setShowToolBar(lShowToolBar);
  bool lShowStatusBar = lSettings.value(SETTING_SHOW_STATUS_BAR, true).toBool();
  mSettingsDialog->setShowStatusBar(lShowStatusBar);
}
void MainWindow::writeSettings()
{
//`Указываем как сохранять настройки. \Sys{QSettings::NativeFormat} --- в формате определенном системой`
//`\Sys{QSettings::UserScope} --- настройки для каждого пользователя отдельно.` 
//`Также устанавливаем имя организации и название программы.`
  QSettings lSettings(QSettings::NativeFormat, QSettings::UserScope, "", qApp->applicationName());
//`Открываем группу настроек` 
  lSettings.beginGroup(SETTINGS_GROUP_VIEW);
//`Записываем настройки` 
  lSettings.setValue(SETTING_SHOW_TOOLBAR, mSettingsDialog->isShowToolBar());
  lSettings.setValue(SETTING_SHOW_STATUS_BAR, mSettingsDialog->isShowStatusBar());
}
void MainWindow::applySettings()
{
//`Читаем настройки установленые в диалоге и применяем их`
  ui->mainToolBar->setVisible(mSettingsDialog->isShowToolBar());
  ui->statusBar->setVisible(mSettingsDialog->isShowStatusBar());
}
\end{lstlisting}

Модифицируем также метод \lstinline!showPreferencesDialog!, чтобы он вызывал считывание настроек. Также добавим
реализацию метода \lstinline!slotPreferencesAccepted!. 
\begin{lstlisting}
void MainWindow::showPreferencesDialog()
{
  readSettings(); //`Считываем настройки и устанавливаем их для диалога`
  mSettingsDialog->show(); //`Показываем диалог настроек`
}
void MainWindow::slotPreferencesAccepted()
{
  writeSettings(); //`Записать новые настройки`
  applySettings(); //`Применить настройки`
}
\end{lstlisting}


В конструкторе главного окна соединим сигнал \Sys{accepted} от диалога к слоту
\Sys{slotPreferencesAccepted}:

\lstinline!connect(mSettingsDialog, SIGNAL(accepted()), this, SLOT(slotPreferencesAccepted()), Qt::UniqueConnection);!

\section[Использование сторонних разработок в собственном проекте]{Использование сторонних (third party) разработок в собственном проекте}
Программная реализация уже существует для множества функциональных возможностей, для большинства распространенных
стандартов и для решения большого количества типичных задач. Например, 
реализация протокола \EN{SMTP} (\EN{Simple Mail Transfer Protocol}) для электронной почты или 
библиотека для быстрого преобразования Фурье, или даже визуальный элемент для
вывода графика функции --- являются примерами задач, с которыми может сталкиваться разработчик. Поэтому программист может
столкнуться с необходимостью исследовать предметную область, спроектировать и разработать собственный вариант решения
для них, выполняя работу заново с самого начала, хотя для этих задач уже существует реализация в других программных
продуктах (библиотеках, инструментариях, и~т.~п.). 

Использование сторонних разработок в собственном проекте может значительно сократить время создания программы, обогатить
функциональные возможности, и, возможно, обеспечить совместимость со стандартами и другими программами, которые уже
существуют. Конечно, в таком случае приходится иметь дело с кодом, созданным другим программистом, который может
содержать свои собственные особенности, дефекты, требования к выполнению. Но в большинстве случаев (если сторонняя
разработка достаточно хорошо протестирована и рассчитана на подобное использование, и поставляется  как библиотека или
фреймворк) это предоставляет серьезные преимущества, поскольку дает возможность избежать повторного решения задачи,
которая была решена другим разработчиком ранее. Особенно это важно для свободного программного обеспечения с открытым
кодом, которое на полную мощность пользуется возможностями повторного использования. 

Конечно, играет важную роль способ лицензирования программного кода, который будет предоставлять возможности для
использования текста или готовой программы в собственных целях. Лицензия может также давать возможность использовать
программное обеспечение или его исходный код в коммерческих проектах. Поэтому особенно важно убедиться в лицензионной
чистоте кода, который Вы будете использовать в своем проекте и в ограничениях, которые лицензия накладывает на его
использование.

В нашем примере мы используем библиотеку \Sys{Qwt}, которая дает дополнительный набор виджетов для вывода графиков,
гистограмм, значений, а также несколько дополнительных элементов управления. Исходный код и документацию можно получить
на сайте \url{http://qwt.sourceforge.net}. 

Откроем папку с исходным кодом и файл проекта \Sys{qwt.pro}. Обратите внимание: файл \Sys{qwt.pro}
содержит строку 

\lstinline!include(qwtconfig.pri)!

Файл \Sys{qwtconfig.pri} служит для настройки компиляции \Sys{Qwt}. Для компиляции примеров и тестового проекта для
исследования \Sys{Qwt} откомментируйте: 
\begin{lstlisting}
QWT_CONFIG  += QwtExamples
QWT_CONFIG  += QwtPlayground
\end{lstlisting}

Также закомментируйте строку для того, чтобы построить отдельную динамическую библиотеку для \Sys{Qwt}, которую мы будем
использовать (эту строку необходимо комментировать только под Windows): 

\lstinline!QWT_CONFIG  += QwtDesignerSelfContained!

Далее отключите \Sys{Shadow Build} и запустите компиляцию в режиме \Sys{Release}. После завершения компиляции мы получим такое
размещение файлов :

\begin{itemize}
\item \Sys{qwt/designer/plugins/designer}--- расширение для \Sys{QtDesigner}, которое даст нам возможность
использовать виджеты \Sys{Qwt} при визуальном проектировании интерфейса;
\item \Sys{qwt/lib} --- содержит динамически загружаемую библиотеку  \Sys{Qwt;}
\item \Sys{qwt/src} --- содержит заголовочные файлы необходимые для разработки;
\end{itemize}
Создадим в папке нового GUI проекта подпапку и назовем ее \Sys{3rdparty.} Добавим внутри нее еще одну папку с
названием \Sys{qwt}. Наконец создадим внутри \Sys{qwt} еще две папки: \Sys{lib} и
\Sys{include}. Внутрь папки \Sys{lib} скопируем содержимое \Sys{qwt/lib} --- построенных
библиотек  \Sys{qwt}. А в папку \Sys{include} скопируем все файлы \Sys{qwt/src}, которые
имеют расширение \Sys{.h}. Наконец для удобства создадим файл для включения в проект 
\Sys{3rdparty/qwt/qwt.pri} и добавим содержание:

\index{Переменные qmake!LIBS}\begin{lstlisting}
INCLUDEPATH += $$PWD/include

LIBS += -L$$PWD/lib
LIBS += -lqwt
\end{lstlisting}

Первая строка \Sys{.pri}-файла указывает путь к размещению
\Sys{.h}-файлов. Переменная 
\index{Переменные qmake!PWD}\Sys{\$\$PWD} хранит значение текущей папки, то есть той, где
находится файл \Sys{qwt.pri}. Вторая строка указывает размещение библиотек
(-L <\emph{путь\_к\_библиотекам}>). Последняя строка указывает на
необходимость связывать программу во время компиляции с библиотекой \Sys{qwt}
(-l <\emph{название\_библиотеки}>, где \emph{название\_библиотеки} ---
название файла библиотеки без расширения и префикса \Sys{lib}).

Отметим, что для того чтобы построить проект в \Sys{Debug} режиме необходимо добавить соответствующие (тоже построенные в
\Sys{Debug} режиме) библиотеки. То же касается и \Sys{Release} режима. 

Теперь добавим этот файл к проекту \Sys{PlotExample.pro}. После строк
\begin{lstlisting}
QT       += core gui
greaterThan(QT_MAJOR_VERSION, 4): QT += widgets
\end{lstlisting}
добавим \lstinline!include(3rdparty/qwt/qwt.pri)!

Теперь мы можем воспользоваться библиотекой \Sys{Qwt} в проекте. Создадим виджет для графика и добавим его на окно.
\begin{lstlisting}
setCentralWidget(new Qwidget); //`Центральный виджет`
QLayout *lLayout = new QVBoxLayout;
centralWidget()->setLayout(lLayout); //`компоновщик для размещения графика`
QwtPlot *lPlot = new QwtPlot; //`Визуальный элемент --- График`
lLayout->addWidget(lPlot);
QwtPlotCanvas *lCanvas = new QwtPlotCanvas();
//`Объект для отображения`
lCanvas->setFrameStyle(QFrame::Box|QFrame::Plain);//`нашего графика`
lPlot->setCanvas(lCanvas);
lPlot->setAxisTitle(QwtPlot::xBottom, "x" );//`Название оси --- x`
lPlot->setAxisScale( QwtPlot::xBottom, -10.0, 10.0 ); //`Границы оси x`
lPlot->setAxisTitle(QwtPlot::yLeft, "y" );//`Название оси --- y`
lPlot->setAxisScale( QwtPlot::yLeft, -10.0, 10.0 ); //`Границы оси у`
new QwtPlotPanner( lCanvas );//`Добавляем инструмент для перетягивания смещения` 
                             //`графика указателем мышки`
new QwtPlotMagnifier( lCanvas );//`Добавляем инструмент для увеличения уменьшения`
                                //`графика роликом мышки
\end{lstlisting}

После запуска программы мы увидим пустое окно графика на экране (рис.~\ref{ch15:refDrawing12}).
\begin{figure}[htb]
\begin{center}
\includegraphics[width=0.5\textwidth]{img/ris_15_13}
\caption[Пример: программа для вывода графика функции.]{Пример: программа для вывода графика функции.}
\label{ch15:refDrawing12}
\end{center}
\end{figure}

\section[Задачи для самостоятельного решения]{Задачи для самостоятельного решения}
\begin{enumerate}
\item Добавьте вывод на панель статуса текущей позиции курсора в текстовом редакторе. Используйте класс \Sys{QStatusBar} и его
метод \Sys{showMessage()}, который принимает как параметр сообщение и количество миллисекунд в течении которых сообщение
видимо. Используйте сигнал \lstinline!QPlainTextEditor::currentPositionChanged()! для определения изменения позиции курсора.
\item Добавьте к настройкам опцию для сохранения геометрии главного окна после закрытия программы. Если флажок опции
включен, то после запуска главное окно будет на той же позиции и тех же размеров, как и в момент перед закрытием
программы. 
\item Создайте проект с графическим интерфейсом. Разместите на окне в компоновщиках 5 различных виджетов. Соедините их
(по 2--3 между собой) сигнально-слотовыми соединениями, таким образом, чтобы они реагировали на изменения состояния друг
друга. Выполните это задание исключительно с помощью редактора форм. Все виджеты должны быть расположены в
компоновщиках и пропорционально изменять размеры при изменении размеров окна.
\item Попробуйте добавить вывод простого графика функции приведенному выше примеру использования компоненты \Sys{Qwt}.
\item Запрограммируйте вывод протабулированной функции на график из файла. Для этого добавьте пункт главного меню
<<File-> Load...>>, который будет показывать диалог открытия файла. После того, как
пользователь выберет файл, программа должна загрузить данные из него и построить график функции.
\item Попробуйте использовать в качестве посторонней компоненты для вывода графика  --- \Sys{QCustomPlot} (сайт проекта :
\url{http://www.qcustomplot.com/}, лицензия GPL). Использование этого проекта не требует компиляции библиотеки --- просто
добавьте файлы \Sys{qcustomplot.h} и  \Sys{qcustomplot.cpp} в проект. Обратите внимание на документацию и примеры, которые
поставляются вместе с проектом.
\end{enumerate}
